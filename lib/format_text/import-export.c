/*
 * Copyright (C) 2001 Sistina Software (UK) Limited.
 *
 * This file is released under the LGPL.
 */

#include "text-rep.h"
#include "metadata.h"
#include "log.h"

#include <stdio.h>

struct flag {
	int mask;
	char *description;
};

static struct flag _vg_flags[] = {
	{ACTIVE, "ACTIVE"},
	{EXPORTED_VG, "EXPORTED"},
	{EXTENDABLE_VG, "EXTENDABLE"},
	{CLUSTERED, "CLUSTERED"},
	{SHARED, "SHARED"},
	{0, NULL}
};

static struct flag _pv_flags[] = {
	{ACTIVE, "ACTIVE"},
	{ALLOCATED_PV, "ALLOCATED"},
	{0, NULL}
};

static struct flag _lv_flags[] = {
	{ACTIVE, "ACTIVE"},
	{READ, "READ"},
	{WRITE, "WRITE"},
	{ALLOC_SIMPLE, "ALLOC_SIMPLE"},
	{ALLOC_STRICT, "ALLOC_STRICT"},
	{ALLOC_CONTIGUOUS, "ALLOC_CONTIGUOUS"},
	{SNAPSHOT, "SNASHOT"},
	{SNAPSHOT_ORG, "SNAPSHOT_ORIGIN"},
	{0, NULL}
};

static void _print_flags(uint32_t status, struct flag *flags, FILE *fp)
{
	int f, first = 1;

	fprintf(fp, "[");
	for (f = 0; flags[f].mask; f++) {
		if (status & flags[f].mask) {
			if (!first)
				fprintf(fp, ", ");
			else
				first = 0;

			fprintf(fp, "\"%s\"", flags[f].name);
			status &= ~flags[f].mask;
		}
	}
	fprintf(fp, "]");

	if (status)
		/* FIXME: agk is this the correct log level ? */
		log_print("Not all flags were successfully exported, "
			  "possible bug.");
}

static int _print_header(FILE *fp, struct volume_group *vg)
{
	fprintf(fp, "# This file was generated by the LVM2 library\n"
		"# %s\n\n", ctime(time(NULL)));
	return 1;
}

static int _print_vg(FILE *fp, struct volume_group *vg)
{
	fprintf(fp, "volume_group {\n");

	fprintf(fp, "\tid = ");
	_print_uuid(&vg.uuid);
	fprintf(fp, "\n\tname = \"%s\"\n", vg->name);

	fprintf(fp, "\tstatus = ");
	_print_flags(fp, vg->status, _vg_flags);

	fprintf(fp, "\n\textent_size = %u", vg->extent_size);
	_print_size_comment(fp, vg->extent_size);

	fprintf(fp, "\tmax_lv = %u\n", vg->max_lv);
	fprintf(fp, "\tmax_pv = %u\n", vg->max_pv);
	fprintf(fp, "}\n");
	return 1;
}

static int _print_pvs(FILE *fp, struct volume_group *vg)
{
	struct list pvh;
	struct physical_volume *pv;
	int count;

	fprintf(fp, "physical_volumes {\n\n");

	list_iterate (pvh, &vg->pvs) {
		fprintf(fp, "\tpv%d {\n", count++);
		pv = &list_item(pvh, struct pv_list)->pv;
		fprintf(fp, "\t\tid = ");
		_print_uuid(fp, &pv->uuid);
		fprintf(fp, "\n\t\tdevice = %s\t# Hint only\n\n",
			dev_name(pv->dev));

		fprintf(fp, "\t\tstatus = ");
		_print_flags(fp, pv->status, _pv_flags);

		fprintf(fp, "\n\n\t\tpe_start = %u\n");
		fprintf(fp, "\t\tpe_count = %u", pv->pe_count);
		_print_size_comment(fp, pe_count * vg->extent_size);
		_fprintf(fp, "\n\t}\n")
	}

	fprintf(fp, "}\n\n");
	return 1;
}

static int _print_lvs(FILE *fp, struct volume_group *vg)
{
	struct list *lvh;
	struct logical_volume *lv;

	fprintf(fp, "logical_volumes {\n");

	list_iterate (lvh, &vg->lvs) {
		lv = &list_item(lvh, struct lv_list)->lv;

		
	}

	fprintf(fp, "}\n");
	return 1;
}

struct volume_group *text_vg_import(struct pool *mem, struct config_file *cf)
{
	log_err("text_vg_import not implemented yet.");
	return NULL;
}

int text_vg_export(FILE *fp, struct volume_group *vg)
{
#define fail do {stack; return 0;} while(0)

	if (!_print_header(fp, vg))
		fail;

	if (!_print_vg(fp, vg))
		fail;

	if (!_print_pvs(fp, vg))
		fail;

	if (!_print_lvs(fp, vg))
		fail;

#undef fail

	return 1;
}

